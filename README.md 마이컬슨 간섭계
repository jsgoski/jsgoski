2022/9/14
파동을 어떻게 만들지 생각하면서 조사한 결과 점을 무수히 많이 찍어 곡선처럼 보이는 직선의 집합체를 만들어 파동을 표현함

파동 1개는 만들었는데 다음 곡선은 어떻게 연속해서 만들지 고민하다가 점들의 집합을 리스트에다 넣어서 for문을 이용하여 개별적인 파동을 만듬

2022/9/15

파동의 시작점(광원)을 vec(-10,0,0)으로 두고 파동이 시작하게 만들고 반도금 거울을 y=-x 직선으로 표현함
그 후 y=-x을 지나가면 아래쪽으로 반사되는 효과를 만들기 위해 파동을 이루는 점이 y=-x보다 오른쪽에 찍히면 즉 파동이 반도금 거울을 지나가면 y=-x에 대해 대칭하여
새로운 리스트에다 점들을 추가적으로 넣은 후 파란색으로 이어주었다.

첫 번째 난관으로 광원에서 출발하여 반도금 거울을 지나간 파동(빨간색)이 오른쪽 거울에 반사되어 다시 반도금 거울에 반사되는 코드를 짤 때 애를 먹었는데 선배의
반드시 그런 복잡한 코딩을 할 필요 없이 여러개의 보이지 않는 파동을 만들어서 같은 효과를 만들라는 조언으로 처음 광원의 좌표를 고려한 여러 개의 파동을 만든후
특정 상황에서만 점을 찍어서 보이게 만들어서 실제로 파동이 반사되는 것과 같은 효과를 만듬

2022/9/24

두 번째 난관으로 스크린을 지나는 파동을 그래프로 표현하고 싶지만 내가 만든 것은 원의 일부분이 아닌 매우 많은 점을 직선으로 이은 직선의 집합이어가지고 스크린의 y좌표를 찍을떄
x값들을 리스트에다 추가한 후 그래프를 그리도록 만들어 봤지만 스크린의 y좌표가 유한 개의 무수히 많은 점의 사이를 지나는 바람에 x값이 찍히지가 않았음

2022/9/27

파동의 주기가 길어 스크린을 지나는 파동이 한개씩밖에 생기지 않을 경우에는 min(,)을 이용해 스크린의 y좌표와의 차가 최소인 점의 x좌표를 구하여 그래프를 만듬

2022/10/19

드디어 해결 
먼저 내가 파동을 만드는 코드는
R = 1
dtheta = 0.01*pi
theta = pi
l_list = []
while theta <=2*pi :
    theta += dtheta
    l_list.append(vec(R*cos(theta),R*sin(theta),0))
l = curve(pos = l_list)

인데 여기서 점을 일일히 찍은 후 그 점들을 이어서 곡선을 만든다.
해결 방법은 두 점이 있고 그 사이에 스크린이 있다고 했을 때 
'첫 번째 점의 y좌표가 스크린의 y좌표보다 작고 그 다음으로 찍은 점의 y좌표가 스크린의 y좌표보다 크거나 같으면 첫 번째 점의 x값을 리스트에다 넣으라'라는 코드를 만들어서 드디어 
여러 개의 파동이 스크린을 지나도 실제로 만나는 x값과 매우 근점한 x값들을 구할 수 있어가지고 그 값들로 점 그래프를 만들어서 상을 표현하였다.
f 2*down_box_y+R*cos(theta)+a <= j and 2*down_box_y+R*cos(theta + dtheta)+a >= j and -R*sin(theta)-b >= 0 :  # 파랑 그래프에 찍을 점 찾기
         dot_blue_list.append(-R*sin(theta)-b)
         print('파랑 찍음')
        
       if a - 2*c + R*sin(theta + 1/2*pi) >= j and a - 2*c + R*sin(theta + 1/2*pi - dtheta) <= j and R*cos(theta + 1/2*pi) >= 0 :     #  노랑 그래프에 찍을 점 찾기
         dot_yellow_list.append(R*cos(theta + 1/2*pi))
         print('노랑 찍음')
